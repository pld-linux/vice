--- vice-2.4/src/gfxoutputdrv/ffmpegdrv.c.orig	2016-10-20 08:39:01.494075298 +0200
+++ vice-2.4/src/gfxoutputdrv/ffmpegdrv.c	2016-10-20 08:39:21.217744132 +0200
@@ -46,29 +46,29 @@
 #include "../sounddrv/soundmovie.h"
 
 static gfxoutputdrv_codec_t avi_audio_codeclist[] = { 
-    { CODEC_ID_MP2, "MP2" },
-    { CODEC_ID_MP3, "MP3" },
-    { CODEC_ID_FLAC, "FLAC" },
-    { CODEC_ID_PCM_S16LE, "PCM uncompressed" },
+    { AV_CODEC_ID_MP2, "MP2" },
+    { AV_CODEC_ID_MP3, "MP3" },
+    { AV_CODEC_ID_FLAC, "FLAC" },
+    { AV_CODEC_ID_PCM_S16LE, "PCM uncompressed" },
     { 0, NULL }
 };
 
 static gfxoutputdrv_codec_t avi_video_codeclist[] = { 
-    { CODEC_ID_MPEG4, "MPEG4 (DivX)" },
-    { CODEC_ID_MPEG1VIDEO, "MPEG1" },
-    { CODEC_ID_FFV1, "FFV1 (lossless)" },
-    { CODEC_ID_H264, "H264" },
-    { CODEC_ID_THEORA, "Theora" },
+    { AV_CODEC_ID_MPEG4, "MPEG4 (DivX)" },
+    { AV_CODEC_ID_MPEG1VIDEO, "MPEG1" },
+    { AV_CODEC_ID_FFV1, "FFV1 (lossless)" },
+    { AV_CODEC_ID_H264, "H264" },
+    { AV_CODEC_ID_THEORA, "Theora" },
     { 0, NULL }
 };
 
 static gfxoutputdrv_codec_t ogg_audio_codeclist[] = { 
-    { CODEC_ID_FLAC, "FLAC" },
+    { AV_CODEC_ID_FLAC, "FLAC" },
     { 0, NULL }
 };
 
 static gfxoutputdrv_codec_t ogg_video_codeclist[] = { 
-    { CODEC_ID_THEORA, "Theora" },
+    { AV_CODEC_ID_THEORA, "Theora" },
     { 0, NULL }
 };
 
@@ -201,9 +201,9 @@
     { "FFMPEGVideoBitrate", VICE_FFMPEG_VIDEO_RATE_DEFAULT,
       RES_EVENT_NO, NULL,
       &video_bitrate, set_video_bitrate, NULL },
-    { "FFMPEGAudioCodec", CODEC_ID_MP3, RES_EVENT_NO, NULL,
+    { "FFMPEGAudioCodec", AV_CODEC_ID_MP3, RES_EVENT_NO, NULL,
       &audio_codec, set_audio_codec, NULL },
-    { "FFMPEGVideoCodec", CODEC_ID_MPEG4, RES_EVENT_NO, NULL,
+    { "FFMPEGVideoCodec", AV_CODEC_ID_MPEG4, RES_EVENT_NO, NULL,
       &video_codec, set_video_codec, NULL },
     { "FFMPEGVideoHalveFramerate", 0, RES_EVENT_NO, NULL,
       &video_halve_framerate, set_video_halve_framerate, NULL },
@@ -278,10 +278,10 @@
     if (c->frame_size <= 1) {
         audio_inbuf_samples = audio_outbuf_size;
         switch(st->codec->codec_id) {
-        case CODEC_ID_PCM_S16LE:
-        case CODEC_ID_PCM_S16BE:
-        case CODEC_ID_PCM_U16LE:
-        case CODEC_ID_PCM_U16BE:
+        case AV_CODEC_ID_PCM_S16LE:
+        case AV_CODEC_ID_PCM_S16BE:
+        case AV_CODEC_ID_PCM_U16LE:
+        case AV_CODEC_ID_PCM_U16BE:
             audio_inbuf_samples >>= 1;
             break;
         default:
@@ -326,7 +326,7 @@
 
     audio_init_done = 1;
 
-    if (ffmpegdrv_fmt->audio_codec == CODEC_ID_NONE)
+    if (ffmpegdrv_fmt->audio_codec == AV_CODEC_ID_NONE)
         return -1;
 
     *audio_in = &ffmpegdrv_audio_in;
@@ -496,8 +496,8 @@
        picture is needed too. It is then converted to the required
        output format */
     tmp_picture = NULL;
-    if (c->pix_fmt != PIX_FMT_RGB24) {
-        tmp_picture = ffmpegdrv_alloc_picture(PIX_FMT_RGB24, 
+    if (c->pix_fmt != AV_PIX_FMT_RGB24) {
+        tmp_picture = ffmpegdrv_alloc_picture(AV_PIX_FMT_RGB24, 
                                                 c->width, c->height);
         if (!tmp_picture) {
             log_debug("ffmpegdrv: could not allocate temporary picture");
@@ -548,7 +548,7 @@
 
      video_init_done = 1;
 
-     if (ffmpegdrv_fmt->video_codec == CODEC_ID_NONE)
+     if (ffmpegdrv_fmt->video_codec == AV_CODEC_ID_NONE)
         return;
 
     st = (*ffmpeglib.p_av_new_stream)(ffmpegdrv_oc, 0);
@@ -573,23 +573,23 @@
     }
     c->time_base.num = 1;
     c->gop_size = 12; /* emit one intra frame every twelve frames at most */
-    c->pix_fmt = PIX_FMT_YUV420P;
+    c->pix_fmt = AV_PIX_FMT_YUV420P;
 
     /* Avoid format conversion which would lead to loss of quality */
-    if (c->codec_id == CODEC_ID_FFV1) {
-        c->pix_fmt = PIX_FMT_RGB32;
+    if (c->codec_id == AV_CODEC_ID_FFV1) {
+        c->pix_fmt = AV_PIX_FMT_RGB32;
     }
 
     /* Use XVID instead of FMP4 FOURCC for better compatibility */
-    if (c->codec_id == CODEC_ID_MPEG4) {
+    if (c->codec_id == AV_CODEC_ID_MPEG4) {
         c->codec_tag = MKTAG('X','V','I','D');
     }
 
 #ifdef HAVE_FFMPEG_SWSCALE
     /* setup scaler */
-    if (c->pix_fmt != PIX_FMT_RGB24) {
+    if (c->pix_fmt != AV_PIX_FMT_RGB24) {
         sws_ctx = (*ffmpeglib.p_sws_getContext)
-            (video_width, video_height, PIX_FMT_RGB24, 
+            (video_width, video_height, AV_PIX_FMT_RGB24, 
              video_width, video_height, c->pix_fmt, 
              SWS_BICUBIC, 
              NULL, NULL, NULL);
@@ -794,7 +794,7 @@
 
     c = video_st->codec;
 
-    if (c->pix_fmt != PIX_FMT_RGB24) {
+    if (c->pix_fmt != AV_PIX_FMT_RGB24) {
         ffmpegdrv_fill_rgb_image(screenshot, tmp_picture);
 #ifdef HAVE_FFMPEG_SWSCALE
         if (sws_ctx != NULL) {
@@ -804,7 +804,7 @@
         }
 #else
         (*ffmpeglib.p_img_convert)((AVPicture *)picture, c->pix_fmt,
-                    (AVPicture *)tmp_picture, PIX_FMT_RGB24,
+                    (AVPicture *)tmp_picture, AV_PIX_FMT_RGB24,
                     c->width, c->height);
 #endif
     } else {
--- vice-2.4/src/gfxoutputdrv/ffmpeglib.h.orig	2016-10-20 08:42:01.130057414 +0200
+++ vice-2.4/src/gfxoutputdrv/ffmpeglib.h	2016-10-20 08:42:13.940218343 +0200
@@ -95,7 +95,7 @@
 #ifdef HAVE_FFMPEG_SWSCALE
 /* swscale functions */
 typedef struct SwsContext * (*sws_getContext_t)(int srcW, int srcH,
-  enum PixelFormat srcFormat, int dstW, int dstH, enum PixelFormat dstFormat,
+  enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat,
   int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, double *param);
 typedef void (*sws_freeContext_t)(struct SwsContext *swsContext);
 typedef int (*sws_scale_t)(struct SwsContext *context, uint8_t* srcSlice[],
